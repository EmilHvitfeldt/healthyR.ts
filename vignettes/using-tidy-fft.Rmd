---
title: "Using Tidy FFT"
subtitle: "Analyze Time Series data with tidy_fft"
author: "Steven P. Sanderson II, MPH"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Using Tidy FFT}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 5
)
```

```{r setup}
library(healthyR.ts)
```

# Introduction

In this vignette we will discuss how to use the `tidy_fft` function, what it does,
and what it produces.

# The Function

The `tidy_fft` function has only a few parameters, six to be exact. There are some
sensible defaults made. It is important that when you use this function, that you
supply it with a full time-series data set, one that has no missing data in it as
this will affect your results.

## Funcation and Parameters

The function and its full parameters are as follows:

```r
tidy_fft(
  .data,
  .date_col,
  .value_col,
  .frequency = 12L,
  .harmonics = 1L,
  .upsampling = 10L
)
```
The `.data` argument is the actual formatted data that will get passed to the function,
the time series data. The `.date_col` argument is the column that holds the datetime
of interest. The `.value` column is the column that holds the value that is being
analyzed by the function, this can be counts, averages, any type of value that is
in the time series. The `.frequency` argument details the cyclical nature of the data, 
is it 12 for monthly, 7 for weekly, etc. The `.harmonics` argument will tell the 
function how many times the `fft` should be run internally and how many filters should
be made. Finally the `.upsampling` argument will tell the function how much the
function should up sample the time parameter.

Let us now work through a simple example.

# Example

## Data

Lets get started with some data.

```{r example_data}
suppressPackageStartupMessages(library(healthyR.data))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(timetk))

data_tbl <- healthyR_data%>%
    filter(ip_op_flag == 'I') %>%
    summarise_by_time(
        .date_var = visit_end_date_time,
        .by = "month",
        value = n()
    ) %>%
    filter_by_time(
        .date_var = visit_end_date_time,
        .start_date = "2015",
        .end_date = "2019"
   ) %>%
  rename(date_col = visit_end_date_time)
```

Now that we have our sample data, let's check it out.

```{r data_glimpse}
glimpse(data_tbl)
```

## Plot Data

Lets take a look at a time series plot of the data.

```{r ts_plt}
suppressPackageStartupMessages(library(timetk))

data_tbl %>%
  plot_time_series(
    .date_var = date_col,
    .value    = value
  )
```

Now that we know what our data looks like, lets go ahead and run it through the function
and assign it to a variable called `output`

## Run Function

```{r run_func}
suppressPackageStartupMessages(library(healthyR.ts))

output <- tidy_fft(
  .data = data_tbl,
  .date_col = date_col,
  .value_col = value,
  .harmonics = 8,
  .frequency = 12,
  .upsampling = 5
)
```

Now that the function has been run against the data, lets explore what we now have.

# Output

The function invisibly returns a list object, hence the need to assign it to a variable.
There are a total of 4 different sections of data in the list that are returned. These 
are:

  * data
  * plots
  * parameters
  * model

## Output Data
